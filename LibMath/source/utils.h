#pragma once

/**
 * this code have been written by Osama Elsharqawy @2024
 * @cerdits in the Implementation and better understanding of 3D Mathematics to @OGLDev
 *
 * This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#if defined(_WIN64) || defined(_WIN32)
#define M_E        2.71828182845904523536   // e
#define M_LOG2E    1.44269504088896340736   // log2(e)
#define M_LOG10E   0.434294481903251827651  // log10(e)
#define M_LN2      0.693147180559945309417  // ln(2)
#define M_LN10     2.30258509299404568402   // ln(10)
#define M_PI       3.14159265358979323846   // pi
#define M_PI_2     1.57079632679489661923   // pi/2
#define M_PI_4     0.785398163397448309616  // pi/4
#define M_1_PI     0.318309886183790671538  // 1/pi
#define M_2_PI     0.636619772367581343076  // 2/pi
#define M_2_SQRTPI 1.12837916709551257390   // 2/sqrt(pi)
#define M_SQRT2    1.41421356237309504880   // sqrt(2)
#define M_SQRT1_2  0.707106781186547524401  // 1/sqrt(2)
#endif

#include <cmath>
#include <random>
#include <cstdio>
#include <cassert>
#include <cfloat>
#include <array>
#include <iostream>

#include <glm/glm.hpp>
#include "vectors.h"
#include <glad/glad.h>

#include "../../LibGL/source/stb_image.h"

class CMatrix4Df;
struct SVector3Df;

#if defined(_WIN64) || defined(_WIN32)
#define SNPRINTF _snprintf_s
#define VSNPRINTF vsnprintf_s
#define RANDOM rand
#define SRANDOM() srand((unsigned int)time(nullptr))
#pragma warning (disable: 4566)
#else
#define SNPRINTF snprintf
#define VSNPRINTF vsnprintf
#define RANDOM random
#define SRANDOM srandom(getpid())
#endif

#define powi(base,exp) (int)powf((float)(base), (float)(exp))

#define ToRadian(x) (float)(((x) * M_PI / 180.0f))
#define ToDegree(x) (float)(((x) * 180.0f / M_PI))

/**
 * RandomFloat: Generates a random floating-point number between 0.0 and 1.0.
 *
 * This function uses the system's random number generator to produce a random
 * integer and scales it to a floating-point value between 0.0 and 1.0.
 *
 * Returns:
 *   A random floating-point number between 0.0 and 1.0.
 */
extern float RandomFloat();

/**
 * RandomInteger: Generates a random integer.
 *
 * This function utilizes a platform-specific random number generator (RANDOM)
 * to produce a random integer.
 *
 * Returns:
 *   A random integer generated by the system's random number generator.
 */
extern int RandomInteger();

/**
 * RandomFloatRangeF: Generates a random float within a specified range.
 *
 * This function takes a start and end value and returns a random float
 * between those values, inclusive. It handles edge cases like empty ranges
 * and reversed ranges, and provides informative error messages.
 *
 * Parameters:
 *   - Start: The lower bound of the range.
 *   - End: The upper bound of the range.
 *   - file: The file name where the function is called.
 *   - line: The line number where the function is called.
 *
 * Returns:
 *   A random float within the specified range, or the start value if the range is empty.
 */
extern float RandomFloatRangeF(float Start, float End, const char* file, int line);

/**
 * RandomIntegerRangeI: Generates a random integer within a specified range.
 *
 * This function takes a start and end value and returns a random integer
 * between those values, inclusive. It handles edge cases like empty ranges
 * and reversed ranges, and provides informative error messages.
 *
 * Parameters:
 *   - Start: The lower bound of the range.
 *   - End: The upper bound of the range.
 *   - file: The file name where the function is called.
 *   - line: The line number where the function is called.
 *
 * Returns:
 *   A random integer within the specified range, or the start value if the range is empty.
 */
extern int RandomIntegerRangeI(int Start, int End, const char* file, int line);

/**
 * RandomFloatRange: Generates a random floating-point number within a specified range.
 *
 * This macro expands to a call to `RandomFloatRangeF` with the current file name and line number.
 *
 * Parameters:
 *   - Start: The lower bound of the range.
 *   - End: The upper bound of the range.
 *
 * Returns:
 *   A random floating-point number within the specified range.
 */
#define RandomFloatRange(Start, End) RandomFloatRangeF(Start, End, __FILE__, __LINE__)

/**
 * RandomIntegerRange: Generates a random integer within a specified range.
 *
 * This macro expands to a call to `RandomIntegerRangeI` with the current file name and line number.
 *
 * Parameters:
 *   - Start: The lower bound of the range.
 *   - End: The upper bound of the range.
 *
 * Returns:
 *   A random integer within the specified range.
 */
#define RandomIntegerRange(Start, End) RandomIntegerRangeI(Start, End, __FILE__, __LINE__)

/**
 * var_mem_zero: Initializes a variable to zero.
 *
 * This macro sets all bytes of the specified variable to zero.
 *
 * Parameters:
 *   - var: The variable to zero.
 */
#define var_mem_zero(var) memset(&var, 0, sizeof(arr));

/**
 * var_mem_set: Initializes a variable to a specific value.
 *
 * This macro sets all bytes of the specified variable to the given value.
 *
 * Parameters:
 *   - var: The variable to set.
 *   - num: The value to set the variable to.
 */
#define var_mem_set(var, num) memset(&var, num, sizeof(arr));

/**
 * arr_mem_zero_ref: Initializes an array to zero, taking its address.
 *
 * This macro sets all bytes of the specified array to zero.
 *
 * Parameters:
 *   - arr: The array to zero.
 */
#define arr_mem_zero_ref(arr) memset(&arr, 0, sizeof(arr));

/**
 * arr_mem_zero: Initializes an array to zero.
 *
 * This macro sets all bytes of the specified array to zero.
 *
 * Parameters:
 *   - arr: The array to zero.
 */
#define arr_mem_zero(arr) memset(arr, 0, sizeof(arr));

/**
 * arr_mem_set: Initializes an array to a specific value.
 *
 * This macro sets all bytes of the specified array to the given value.
 *
 * Parameters:
 *   - arr: The array to set.
 *   - num: The value to set the array to.
 */
#define arr_mem_set(arr, num) memset(arr, num, sizeof(arr));

/**
 * arr_size: Calculates the size of an array in elements.
 *
 * This macro calculates the number of elements in the specified array by dividing
 * the size of the array in bytes by the size of a single element.
 *
 * Parameters:
 *   - arr: The array to calculate the size of.
 *
 * Returns:
 *   The number of elements in the array.
 */
#define arr_size(arr) (sizeof(arr) / sizeof(arr[0]))

/**
 * safe_free: Free a malloc’d pointer and set it to nullptr.
 * 
 * free(*p) and then set *p = nullptr to avoid dangling pointers.
 * 
 * Parameters:
 * - p: the pointer to the object to free.
 */
#define safe_free(p) { if (p) free(p); p = nullptr; }

/**
 * safe_free: Call Release() on a COM-style object and set pointer to nullptr.
 * 
 * calls p->Release() and then sets p = nullptr to avoid dangling.
 * 
 * Parameters:
 * - p: the pointer to a COM-style object to Release.
 */
#define safe_release(p) { if (p) p->Release(); p = nullptr; }

/**
 * safe_delete: Delete a C++ object and set its pointer to nullptr.
 *
 * delete p and then set p = nullptr to avoid dangling pointers.
 *
 * Parameters:
 * - p: the pointer to the object to delete
 */
#define safe_delete(p) { if (p) delete p; p = nullptr; }

/**
 * safe_delete_arr: Delete a C++ array and set its pointer to nullptr.
 *
 * delete[] p and then set p = nullptr to avoid dangling pointers.
 *
 * Parameters:
 * - p: the pointer to the array to delete[]
 */
#define safe_delete_arr(p) { if (p) delete[] p; p = nullptr; }

/**
 * GLCheckError: Check for OpenGL errors.
 *
 * Returns:
 *   true if the last glGetError() was GL_NO_ERROR, false otherwise.
 */
#define GLCheckError() (glGetError() == GL_NO_ERROR)

/**
 * Structure to hold parameters for a perspective projection matrix
 *
 * This structure contains all the necessary information to create a perspective projection matrix
 * for rendering 3D scenes. The perspective projection simulates depth, making objects appear smaller
 * as they get farther from the camera, similar to how the human eye perceives depth.
 *
 * Members:
 *   - FOV: Field of View, defines the vertical angle (in degrees or radians) for the camera's view.
 *   - Width: The width of the viewport (screen/window) for rendering.
 *   - Height: The height of the viewport for rendering.
 *   - zNear: The near clipping plane distance. Objects closer than this will not be rendered.
 *   - zFar: The far clipping plane distance. Objects farther than this will not be rendered.
 */
typedef struct SPersProjInfo
{
    float FOV;      /* Vertical Field of View in degrees or radians */
    float Width;    /* Width of the viewport (screen/window) */
    float Height;   /* Height of the viewport */
    float zNear;    /* Near clipping plane distance */
    float zFar;     /* Far clipping plane distance */
} TPersProjInfo;

/**
 * Structure to hold parameters for an orthogonal projection matrix
 *
 * This structure contains the parameters needed to define an orthographic projection matrix, which
 * is used when you want to render objects with no perspective distortion. In this projection, objects
 * appear the same size regardless of their distance from the camera, which is ideal for 2D views,
 * technical drawings, or isometric views.
 *
 * Members:
 *   - fRight: The right plane of the orthogonal view frustum.
 *   - fLeft: The left plane of the orthogonal view frustum.
 *   - fBottom: The bottom plane of the orthogonal view frustum.
 *   - fTop: The top plane of the orthogonal view frustum.
 *   - fNearZ: The near clipping plane distance.
 *   - fFarZ: The far clipping plane distance.
 *   - fWidth: The width of the view in world-space units.
 *   - fHeight: The height of the view in world-space units.
 */
typedef struct SOrthoProjInfo
{
    float fLeft;    /** The left plane of the orthogonal frustum */
    float fRight;   /** The right plane of the orthogonal frustum */

    float fBottom;  /** The bottom plane of the orthogonal frustum */
    float fTop;     /** The top plane of the orthogonal frustum */

    float fNearZ;   /** The near clipping plane distance */
    float fFarZ;    /** The far clipping plane distance */

    float fWidth;   /** The width of the orthogonal view in world-space units */
    float fHeight;  /** The height of the orthogonal view in world-space units */
} TOrthoProjInfo;

#ifndef NDEBUG
#   define ASSERT(condition, message) \
    do { \
        if (! (condition)) { \
            std::cerr << "Assertion `" #condition "` failed in " << __FILE__ \
                      << " line " << __LINE__ << ": " << message << std::endl; \
            std::terminate(); \
        } \
    } while (false)
#else
#   define ASSERT(condition, message) do { } while (false)
#endif

#define GLExitIfError()                                                          \
{                                                                               \
    GLenum Error = glGetError();                                                \
                                                                                \
    if (Error != GL_NO_ERROR) {                                                 \
        printf("OpenGL error in %s:%d: 0x%x\n", __FILE__, __LINE__, Error);     \
        exit(0);                                                                \
    }                                                                           \
}

extern int CalculateNextPowerOfTwo(int iNum);

extern bool IsPointInsideViewFrustum(const SVector3Df& v3Point, const CMatrix4Df& matViewProj);

extern bool ReadFile(const char* fileName, std::string& outFile);

extern bool IntersectTriangle(const SVector3Df& c_orig,
    const SVector3Df& c_dir,
    const SVector3Df& c_v0,
    const SVector3Df& c_v1,
    const SVector3Df& c_v2,
    float* pu,
    float* pv,
    float* pt);

// Moller–Trumbore algorithm
extern bool IntersectTriangleNew(const SVector3Df& rayOrigin,
    const SVector3Df& rayDir,
    const SVector3Df& v0,
    const SVector3Df& v1,
    const SVector3Df& v2,
    float* outU, float* outV, float* outT);

extern bool IntersectQuad(const SVector3Df& O,         // ray origin
    const SVector3Df& D,                        // ray direction (normalized)
    const SVector3Df& v0,                       // quad corner 0
    const SVector3Df& v1,                       // quad corner 1
    const SVector3Df& v2,                       // quad corner 2
    const SVector3Df& v3,                       // quad corner 3
    SVector3Df& outPoint,                       // where we store the hit
    float& outT);                               // ray parameter

extern bool RayIntersectsAABB(const SVector3Df& rayOrigin, const SVector3Df& rayDir,
    const SVector3Df& aabbMin, const SVector3Df& aabbMax);

namespace MyMath
{
    inline float fmin(float fMin, float fMax)
    {
        return (fMin < fMax) ? fMin : fMax;
    }

    inline float fmax(float fMin, float fMax)
    {
        return (fMax > fMin) ? fMax : fMin;
    }

    inline float fminmax(float fMin, float fVal, float fMax)
    {
        float fNewVal = (fMin > fVal) ? fMin : fVal;
        return (fMax < fNewVal) ? fMax : fNewVal;
    }

    inline float fclamp(float fX, float fMinVal, float fMaxVal)
    {
        return (fmin(fmax(fX, fMinVal), fMaxVal));
    }

    inline glm::vec3 GenerateRandomVec3GLM()
    {
        std::random_device rd;  //Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
        std::uniform_real_distribution<float> dis(0.0, 100.0);

        float x, y, z;
        x = dis(gen);
        y = dis(gen);
        z = dis(gen);

        return glm::vec3(x, y, z);
    }

    inline SVector3Df GenerateRandomVector3()
    {
        std::random_device rd;  //Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
        std::uniform_real_distribution<float> dis(0.0, 100.0);

        float x, y, z;
        x = dis(gen);
        y = dis(gen);
        z = dis(gen);

        return SVector3Df(x, y, z);
    }

    inline GLint iceil(GLint n, GLint d)
    {
        return static_cast<GLint>(std::ceil(static_cast<GLfloat>(n / d)));
    }
}
